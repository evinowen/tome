import { describe, beforeEach, afterEach, it, expect, vi } from 'vitest'
import { assemble } from '?/helpers'
import Vue from 'vue'
import { createVuetify } from 'vuetify'
import { createStore } from 'vuex'
import { State, key } from '@/store'
import EditorInterface from '@/components/EditorInterface.vue'

vi.mock('lodash', () => ({
  debounce: (callback) => {
    callback.cancel = vi.fn()
    callback.flush = vi.fn()
    return callback
  },
  delay: (callback) => callback()
}))

vi.mock('mark.js', () => {
  class Mark {
    unmark = vi.fn((options) => options.done(true))
    markRegExp = vi.fn((regex, options) => options.done(3))
  }

  return { default: Mark }
})

function GenerateElementList (array) {
  return array.map(() => ({
    classList: {
      add: vi.fn(),
      remove: vi.fn()
    },
    scrollIntoView: vi.fn()
  }))
}

const markjs_results_with_parents = GenerateElementList(['one-parent', 'one', 'two-parent', 'two', 'three-parent', 'three'])
const markjs_results = GenerateElementList(['one', 'two', 'three'])

// describe('components/EditorInterface', () => {
//   let vuetify
//   let store
//   let store_dispatch
//   let codemirror_cursor
//   let codemirror

  // beforeEach(() => {
  //   document.getSelection = vi.fn(() => ({ toString: () => '' }) as unknown as Selection)

  //   // eslint-disable-next-line @typescript-eslint/no-explicit-any
  //   const settable_store = store as { state: any }
  //   settable_store.state = Vue.observable({
  //     files: {
  //       active: '/README.md',
  //       error: undefined,
  //       tree: undefined,
  //       ghost: undefined,
  //       editing: false,
  //       watcher: undefined,
  //       directory: {
  //         '/README.md': {
  //           path: '/README.md',
  //           name: 'README.md',
  //           relative: 'README.md',
  //           extension: '.md',
  //           image: false,
  //           directory: false,
  //           expanded: false,
  //           readonly: false,
  //           document: {
  //             content: '# README\n'
  //           }
  //         },
  //         '/document.md': {
  //           path: '/document.md',
  //           name: 'document.md',
  //           relative: 'document.md',
  //           extension: '.md',
  //           image: false,
  //           directory: false,
  //           expanded: false,
  //           readonly: false,
  //           document: {
  //             content: '# Document Data\n'
  //           }
  //         }
  //       }
  //     },
  //     search: {
  //       query: '',
  //       results: [],
  //       navigation: {
  //         target: 1,
  //         total: 0
  //       }
  //     },
  //     configuration: {
  //       dark_mode: false
  //     },
  //     system: {
  //       edit: false
  //     }
  //   })

  //   vuetify = createVuetify()

  //   store = createStore<State>({
  //     state: {
  //     }
  //   })

  //   store_dispatch = vi.spyOn(store, 'dispatch')

  //   codemirror_cursor = {
  //     findNext: vi.fn(() => false),
  //     findPrevious: vi.fn(),
  //     from: vi.fn(() => 1),
  //     to: vi.fn(() => 100)
  //   }

  //   codemirror = {
  //     addOverlay: vi.fn(),
  //     removeOverlay: vi.fn(),
  //     refresh: vi.fn(),
  //     getSearchCursor: vi.fn(() => codemirror_cursor),
  //     getSelection: vi.fn(() => 'selected text'),
  //     setSelection: vi.fn(),
  //     scrollIntoView: vi.fn(),
  //     replaceSelection: vi.fn(),
  //     setOption: vi.fn(),
  //     isClean: vi.fn(() => false),
  //     save: vi.fn(),
  //     doc: {
  //       getValue: vi.fn(() => 'Value'),
  //       eachLine: vi.fn(),
  //       setValue: vi.fn()
  //     }
  //   }
  // })

  // afterEach(() => {
  //   vi.clearAllMocks()
  // })

  // const factory = assemble(EditorInterface, {
  //   edit: false,
  //   commit: false,
  //   push: false
  // }).context(() => (
  //   {
  //     global: {
  //       plugins: [ vuetify, [store, key] ],
  //       stubs: {
  //         ActionView: true,
  //         CommitView: true,
  //         EmptyPane: true,
  //         PushView: true,
  //         Explorer: true,
  //         codemirror: {
  //           template: '<div />',
  //           data: () => ({ codemirror })
  //         }
  //       }
  //     }
  //   }
  // ))

  // it('should mount into test scafolding without error', async () => {
  //   const wrapper = factory.wrap()
  //   expect(wrapper).toBeDefined()
  // })

  // it('should dispatch files/debounce_save with path and content when save is called with path', async () => {
  //   const wrapper = factory.wrap()

  //   const path = './file_path'
  //   await wrapper.vm.save(path)

  //   const [action, data] = store_dispatch.mock.calls.find(([action]) => (action as unknown as string) === 'files/debounce_save')

  //   expect(action).toBeDefined()
  //   expect(data).toBeDefined()
  //   // expect(data.path).toEqual(path)
  //   // expect(data.content).toBeDefined()
  // })

  // it('should redirect to save with active path when input is called', async () => {
  //   const wrapper = factory.wrap()
  //   wrapper.vm.save = vi.fn()

  //   await wrapper.vm.input()

  //   expect(wrapper.vm.save).toHaveBeenCalledTimes(1)
  // })

  // it('should render current content using marked', async () => {
  //   const wrapper = factory.wrap()
  //   await wrapper.vm.$nextTick()

  //   store.state.files.directory['/document.md'].document.content = '# Mock'
  //   store.state.files.active = '/document.md'

  //   await new Promise(resolve => setTimeout(resolve))

  //   await wrapper.vm.$nextTick()

  //   expect(wrapper.vm.rendered).toEqual('<h1 id="mock">Mock</h1>\n')
  // })

  // it('should abort search highlight update if no editor is visible', async () => {
  //   const wrapper = factory.wrap()
  //   await wrapper.vm.$nextTick()

  //   store.state.files.directory['/document.md'].document.content = ''

  //   expect(wrapper.vm.overlay).toBeUndefined()

  //   store.state.search.query = 'mock'
  //   await wrapper.vm.$nextTick()

  //   expect(wrapper.vm.overlay).toBeUndefined()
  // })

  // it('should update search highlight when the search query changes in render mode', async () => {
  //   const wrapper = factory.wrap()
  //   await wrapper.vm.$nextTick()

  //   store.state.files.directory['/document.md'].document.content = '# Mock'
  //   store.state.files.active = '/document.md'

  //   store.state.search.query = 'first'

  //   await wrapper.vm.$nextTick()

  //   expect(wrapper.vm.query).toEqual('first')
  //   expect(wrapper.vm.rendered).toEqual('<h1 id="mock">Mock</h1>\n')

  //   wrapper.vm.$refs.rendered.querySelectorAll = vi.fn((test) => {
  //     switch (test) {
  //       case 'mark > mark': return markjs_results_with_parents
  //       case 'mark': return markjs_results
  //     }
  //   })

  //   expect(wrapper.vm.mode.read.results.length).toBe(0)

  //   store.state.search.query = 'second'

  //   await wrapper.vm.$nextTick()

  //   expect(wrapper.vm.mode.read.results.length).not.toBeUndefined()
  //   expect(wrapper.vm.mode.read.results.length).not.toBe(0)
  // })

  // it('should trigger search when the edit attribute changes', async () => {
  //   store.state.system.edit = false

  //   const wrapper = factory.wrap()
  //   wrapper.vm.search = vi.fn()
  //   expect(wrapper.vm.search).toHaveBeenCalledTimes(0)

  //   store.state.system.edit = true
  //   await wrapper.vm.$nextTick()

  //   expect(wrapper.vm.search).toHaveBeenCalledTimes(1)
  // })

  // it('should trigger navigation when the target attribute changes', async () => {
  //   const wrapper = factory.wrap()
  //   await wrapper.vm.$nextTick()

  //   store.state.search.navigation.target = 1

  //   await wrapper.vm.$nextTick()

  //   wrapper.vm.navigate = vi.fn()

  //   store.state.search.navigation.target = 2
  //   await wrapper.vm.$nextTick()

  //   expect(wrapper.vm.navigate).toHaveBeenCalledTimes(1)
  // })

  // it('should update search highlight when the search query changes in edit mode', async () => {
  //   store.state.system.edit = true

  //   const wrapper = factory.wrap()
  //   await wrapper.vm.$nextTick()

  //   store.state.files.active = '/document.md'
  //   store.state.files.directory['/document.md'].document.content = '# Mock'
  //   store.state.search.query = 'first'

  //   await wrapper.vm.$nextTick()

  //   expect(wrapper.vm.query).toEqual('first')

  //   codemirror.addOverlay.mockClear()
  //   codemirror.removeOverlay.mockClear()
  //   codemirror.setSelection.mockClear()
  //   codemirror.scrollIntoView.mockClear()

  //   store.state.search.query = 'second'
  //   await wrapper.vm.$nextTick()

  //   expect(codemirror.removeOverlay).toHaveBeenCalledTimes(1)
  //   expect(codemirror.addOverlay).toHaveBeenCalledTimes(1)

  //   expect(codemirror.setSelection).toHaveBeenCalled()
  //   expect(codemirror.setSelection.mock.calls[0][0]).toBe(1)
  //   expect(codemirror.setSelection.mock.calls[0][1]).toBe(100)

  //   expect(codemirror.scrollIntoView).toHaveBeenCalled()
  //   expect(codemirror.scrollIntoView.mock.calls[0][0]).toEqual({ from: 1, to: 100 })
  // })

  // it('should align search selection with target selection when higher then target and navigate triggers in edit mode', async () => {
  //   store.state.system.edit = true
  //   const wrapper = factory.wrap()
  //   await wrapper.vm.$nextTick()

  //   store.state.files.directory['/document.md'].document.content = '# Mock'
  //   store.state.files.active = '/document.md'

  //   await wrapper.vm.$nextTick()

  //   codemirror_cursor.findNext.mockImplementationOnce(() => true)
  //   codemirror_cursor.findNext.mockImplementationOnce(() => true)
  //   codemirror_cursor.findNext.mockImplementationOnce(() => true)

  //   store.state.search.query = 'mock'

  //   wrapper.setData({ mode: { write: { position: 4 } } })
  //   expect(wrapper.vm.mode.write.position).toBe(4)

  //   store.state.search.navigation.target = 2

  //   await wrapper.vm.$nextTick()

  //   expect(wrapper.vm.mode.write.position).toBe(2)
  // })

  // it('should set a functional CodeMirror mode object to overlay when search query changes in edit mode', async () => {
  //   store.state.system.edit = true
  //   const wrapper = factory.wrap()
  //   await wrapper.vm.$nextTick()

  //   store.state.files.active = '/document.md'
  //   store.state.files.directory['/document.md'].document.content = '# Mock'
  //   store.state.search.query = 'mock'

  //   await wrapper.vm.$nextTick()

  //   expect(wrapper.vm.overlay).toBeDefined()
  //   expect(wrapper.vm.overlay.token).toBeDefined()

  //   const token_front = { pos: 0, string: 'mock match front', skipToEnd: vi.fn() }
  //   wrapper.vm.overlay.token(token_front)
  //   expect(token_front.skipToEnd).toHaveBeenCalledTimes(0)

  //   const token_middle = { pos: 0, string: 'match mock middle', skipToEnd: vi.fn() }
  //   wrapper.vm.overlay.token(token_middle)
  //   expect(token_middle.skipToEnd).toHaveBeenCalledTimes(0)

  //   const token_end = { pos: 0, string: 'match end mock', skipToEnd: vi.fn() }
  //   wrapper.vm.overlay.token(token_end)
  //   expect(token_end.skipToEnd).toHaveBeenCalledTimes(0)

  //   const token_none = { pos: 0, string: 'match none', skipToEnd: vi.fn() }
  //   wrapper.vm.overlay.token(token_none)
  //   expect(token_none.skipToEnd).toHaveBeenCalledTimes(1)
  // })

  // it('should dispatch clipboard/text with codemirror data when cut is called in edit mode', async () => {
  //   store.state.system.edit = true
  //   store.state.files.active = '/document.md'

  //   const wrapper = factory.wrap()
  //   await wrapper.vm.context.find(item => item.title === 'Cut').action()

  //   const [action, data] = store_dispatch.mock.calls.find(([action]) => (action as unknown as string) === 'clipboard/text')

  //   expect(action).toBeDefined()
  //   expect(data).toBeDefined()
  // })

  // it('should dispatch clipboard/text with codemirror data when copy is called in edit mode', async () => {
  //   store.state.system.edit = true
  //   store.state.files.active = '/document.md'

  //   const wrapper = factory.wrap()
  //   await wrapper.vm.context.find(item => item.title === 'Copy').action()

  //   const [action, data] = store_dispatch.mock.calls.find(([action]) => (action as unknown as string) === 'clipboard/text')

  //   expect(action).toBeDefined()
  //   expect(data).toBeDefined()
  // })

  // it('should dispatch clipboard/text with codemirror data when copy is called in read mode', async () => {
  //   store.state.system.edit = false
  //   store.state.files.active = '/document.md'

  //   const wrapper = factory.wrap()
  //   await wrapper.vm.context.find(item => item.title === 'Copy').action()

  //   const [action, data] = store_dispatch.mock.calls.find(([action]) => (action as unknown as string) === 'clipboard/text')

  //   expect(action).toBeDefined()
  //   expect(data).toBeDefined()
  // })

  // it('should paste clipboard into codemirror when paste is called in edit mode', async () => {
  //   store.state.system.edit = true
  //   const wrapper = factory.wrap()

  //   store.state.files.active = '/document.md'

  //   await wrapper.vm.$nextTick()

  //   await wrapper.vm.context.find(item => item.title === 'Paste').action()

  //   expect(wrapper.vm.$refs.editor.codemirror.replaceSelection).toHaveBeenCalledTimes(1)
  // })

  // it('should disable cut when in read mode', async () => {
  //   const wrapper = factory.wrap({})
  //   await wrapper.vm.$nextTick()

  //   let active
  //   for (const item of wrapper.vm.context) {
  //     if (item.title === 'Cut') {
  //       active = item.active
  //     }
  //   }

  //   expect(active()).toBeFalsy()
  // })

  // it('should disable paste when in read mode', async () => {
  //   const wrapper = factory.wrap({})
  //   await wrapper.vm.$nextTick()

  //   let active
  //   for (const item of wrapper.vm.context) {
  //     if (item.title === 'Paste') {
  //       active = item.active
  //     }
  //   }

  //   expect(active()).toBeFalsy()
  // })

  // it('should enable cut when in edit mode', async () => {
  //   store.state.system.edit = true
  //   store.state.files.active = '/document.md'

  //   const wrapper = factory.wrap()

  //   await wrapper.vm.$nextTick()

  //   let active
  //   for (const item of wrapper.vm.context) {
  //     if (item.title === 'Cut') {
  //       active = item.active
  //     }
  //   }

  //   expect(active()).toBeTruthy()
  // })

  // it('should enable paste when in edit mode', async () => {
  //   store.state.system.edit = true
  //   store.state.files.active = '/document.md'

  //   const wrapper = factory.wrap({ edit: true })

  //   await wrapper.vm.$nextTick()

  //   let active
  //   for (const item of wrapper.vm.context) {
  //     if (item.title === 'Paste') {
  //       active = item.active
  //     }
  //   }

  //   expect(active()).toBeTruthy()
  // })
// })
